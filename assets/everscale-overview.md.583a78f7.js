import{_ as e,b as a,c as t,f as s}from"./app.76e0960b.js";const f=JSON.parse('{"title":"Everscale Overview","description":"","frontmatter":{},"headers":[{"level":2,"title":"Data representation","slug":"data-representation"},{"level":3,"title":"A small example of cells data","slug":"a-small-example-of-cells-data"},{"level":2,"title":"Blockchain architecture","slug":"blockchain-architecture"},{"level":3,"title":"A little about shard id","slug":"a-little-about-shard-id"},{"level":2,"title":"Accounts","slug":"accounts"},{"level":2,"title":"Messages","slug":"messages"},{"level":3,"title":"Logical time","slug":"logical-time"},{"level":2,"title":"Transactions","slug":"transactions"},{"level":3,"title":"Phases of an ordinary transaction","slug":"phases-of-an-ordinary-transaction"},{"level":3,"title":"Transaction fees","slug":"transaction-fees"}],"relativePath":"everscale-overview.md","lastUpdated":1669741002000}'),n={name:"everscale-overview.md"},o=s(`<h1 id="everscale-overview" tabindex="-1">Everscale Overview <a class="header-anchor" href="#everscale-overview" aria-hidden="true">#</a></h1><p>Before integrating with the blockchain, it is important to understand how it works. The following will be a brief description of the various aspects that are important to understand before considering further work with the library.</p><p>For a detailed explanation of how everything works, read <a href="https://ton.org/tblkch.pdf" target="_blank" rel="noopener noreferrer">the whitepaper</a> or <a href="https://docs.everscale.network/arch" target="_blank" rel="noopener noreferrer">documentation</a>.</p><h2 id="data-representation" tabindex="-1">Data representation <a class="header-anchor" href="#data-representation" aria-hidden="true">#</a></h2><p><em>Please refer to Chapter 1.1 of <a href="https://ton.org/tblkch.pdf" target="_blank" rel="noopener noreferrer">the whitepaper</a></em></p><p>At a basic level everything in Ever is a <em>cell</em>. Each <em>cell</em> consists of up to <strong>1023 data bits</strong> and <strong>up to 4 references</strong> to other cells. Cyclic cell references are not allowed so the cells are usually organized into <em>tree of cells</em>.</p><p>Any value may be represented as a tree of cells. The specific structure of representing various data is described in <a href="https://github.com/tonlabs/ton-labs-abi/blob/master/docs/ABI_2.0_spec.md" target="_blank" rel="noopener noreferrer">the ABI specification</a>.</p><p>In addition to the parameters of the cell itself, there are some restrictions on the structure as a whole:</p><ul><li><p>Max tree of cells depth is <strong>2<sup>16</sup></strong></p></li><li><p>Max tree of cells depth for an external messages is <strong>512</strong></p></li><li><p>The contract pays for the storage of this data, so it is important to keep track of how you describe your structures, order is important for tighter packing. If there is a lot of nested data in the contract, then over time it can use up its entire balance.</p><ul><li>In the <em>masterchain</em> each bit costs 1000 units and ever reference costs 500000 units.</li><li>In the <em>base workchain</em> each bit costs 1 unit and every reference costs 500 units.</li></ul><p><em>(the actual values can be viewed in the 18th parameter of the network config)</em></p></li></ul><blockquote><h3 id="a-small-example-of-cells-data" tabindex="-1">A small example of cells data <a class="header-anchor" href="#a-small-example-of-cells-data" aria-hidden="true">#</a></h3><p>Tuple type: <code>(uint32, bool, uint32[])</code></p><p>Values: <code>(0x539, true, [0x0B, 0x16])</code></p><p>Cell structure to represent this values:</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">Ordinary   l: 000   bits: 66   refs: 1   data: 00000539800000016_</span></span>
<span class="line"><span style="color:#A6ACCD;">hashes: 29a11f1e37e0c64354f52be1f517992639e91a7d07487630c1e3800a479277ba</span></span>
<span class="line"><span style="color:#A6ACCD;">depths: 2</span></span>
<span class="line"><span style="color:#A6ACCD;">  \u2514\u2500Ordinary   l: 000   bits: 9   refs: 2   data: cfc_</span></span>
<span class="line"><span style="color:#A6ACCD;">  hashes: a590c29333e1d2060a079b8bd1f8f57a56408d87e1586ccbe6caa888ae34abc0</span></span>
<span class="line"><span style="color:#A6ACCD;">  depths: 1</span></span>
<span class="line"><span style="color:#A6ACCD;">  \u251C\u2500Ordinary   l: 000   bits: 34   refs: 0   data: 00000002e_</span></span>
<span class="line"><span style="color:#A6ACCD;">  \u2502 hashes: 3d10b2cb5aa6f262a35dc82a384d326f9b3667c1c8002021382987a88ca8482b</span></span>
<span class="line"><span style="color:#A6ACCD;">  \u2502 depths: 0</span></span>
<span class="line"><span style="color:#A6ACCD;">  \u2514\u2500Ordinary   l: 000   bits: 34   refs: 0   data: 00000005a_</span></span>
<span class="line"><span style="color:#A6ACCD;">    hashes: 43bd1f7b6ad2214e74ff517098fc7c45b9acd979b0da5e0cc804f6af313ce474</span></span>
<span class="line"><span style="color:#A6ACCD;">    depths: 0</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>Encoded cell: <code>te6ccgEBBAEAIAABEQAABTmAAAABYAECA8/AAwIACQAAAAWgAAkAAAAC4A==</code></p><blockquote><p>By the way, you can play with the cells on <a href="https://ever.bytie.moe/serializer" target="_blank" rel="noopener noreferrer">ever.bytie.moe</a></p></blockquote></blockquote><p>In some places the hash of the cell may be needed. It is important to understand that this is a kind of complex hash from the representation of a cell in a specific format, so it is better to use <code>getBocHash</code> method or calculate it in advance.</p><p>Note that when you work with the extension and this library, all cells are passed or returned as a base64 string (see the encoded cell in the example above).</p><h2 id="blockchain-architecture" tabindex="-1">Blockchain architecture <a class="header-anchor" href="#blockchain-architecture" aria-hidden="true">#</a></h2><p><em>Please refer to Chapter 1.2 of <a href="https://ton.org/tblkch.pdf" target="_blank" rel="noopener noreferrer">the whitepaper</a></em></p><p>Everscale is a highly scalable blockchain. This was achieved using a complex architecture with <em>The Infinite Sharding Paradigm</em>. Each account can be considered as lying in its separate <em>&quot;accountchain&quot;</em>, and the (virtual) blocks of these <em>accountchains</em> are grouped into <em>shardchain</em> blocks. Because of this, each block and its state can be easily divided into two distinct parts at any time with different sets of these accountchains (that is, each shardchain can split into two parts, and in the same way merge back after a while).</p><p>In addition to the account blocks, the shardchain block contains some general information such as unix/logical time, sequence numbers of its predecessors, some information about validator set and other stuff.</p><p>Several shardchains work within the same group called the <em>workchain</em>. At the very start of the network each workchain contains only one shardchain. Further, once in several blocks, shardchains are divided up to a certain minimum number of times. After that, they will be split as soon as there is a sufficiently large load in any of them and merge back as soon as the load subsides</p><p>At the moment, there are two workchains in Everscale - <em>masterchain</em> (id -1) and <em>base workchain</em> (id 0). Validators can vote to add a new workchain, but so far no one has done this on the mainnet. Most of the contracts in the Everscale work in the base workchain. It has relatively small commissions and many shards.</p><p>Masterchain is a special case of workchain. It has notable differences:</p><ul><li><p>Shardchains in masterchain cannot be split or merged, so there is only one shardchain in it.</p></li><li><p>Blocks in it contain additional important information:<br><em>ShardHashes</em>, a binary tree with a list of all defined shardchains along with the hashes of the latest block inside each of the listed shardchains. It is the inclusion of a shardchain block into this structure that makes a shardchain block <em>&quot;canonical&quot;</em>, and enables other shardchains blocks to refer to data (e.g., outbound messages) contained in the shardchain block.</p></li><li><p>The state of masterchain contains global configuration parameters of the whole TON blockchain, such as gas prices and other stuff.</p></li></ul><blockquote><h3 id="a-little-about-shard-id" tabindex="-1">A little about shard id <a class="header-anchor" href="#a-little-about-shard-id" aria-hidden="true">#</a></h3><p>Each shard has its own id which is also used to determine which account can get into it.</p><p>It is a 64-bit unsigned integer which has a mask part and one marker bit. In binary form it looks like <code>xx..xx100..00</code> where the <code>x</code> part is a mask (may be absent) and a marker bit follows immediately after this mask.</p><p>At the very start of the network, there is one shard with the id <code>800...000</code> (in hex form). It has only one marker bit at the beginning. Further, when this shard is split, for the new ids mask bit is shifted to the right and two shards are created with different values for the bit before the shifted one.</p><p>A small visual diagram for this in binary form:</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">.1000000....                 | mask:</span></span>
<span class="line"><span style="color:#A6ACCD;">----------------------------------------------------------</span></span>
<span class="line"><span style="color:#A6ACCD;">.1000000.... -&gt; 0.100000.... | mask: 0</span></span>
<span class="line"><span style="color:#A6ACCD;">                1.100000.... | mask: 1</span></span>
<span class="line"><span style="color:#A6ACCD;">----------------------------------------------------------</span></span>
<span class="line"><span style="color:#A6ACCD;">0.100000.... -&gt; 00.10000.... | mask: 00</span></span>
<span class="line"><span style="color:#A6ACCD;">                01.10000.... | mask: 01</span></span>
<span class="line"><span style="color:#A6ACCD;">1.100000.... -&gt; 10.10000.... | mask: 10</span></span>
<span class="line"><span style="color:#A6ACCD;">                11.10000.... | mask: 11</span></span>
<span class="line"><span style="color:#A6ACCD;">----------------------------------------------------------</span></span>
<span class="line"><span style="color:#A6ACCD;">00.10000.... -&gt; 000.1000.... | mask: 000</span></span>
<span class="line"><span style="color:#A6ACCD;">                001.1000.... | mask: 001</span></span>
<span class="line"><span style="color:#A6ACCD;">01.10000.... -&gt; 010.1000.... | mask: 010</span></span>
<span class="line"><span style="color:#A6ACCD;">                011.1000.... | mask: 011</span></span>
<span class="line"><span style="color:#A6ACCD;">10.10000.... -&gt; 100.1000.... | mask: 100</span></span>
<span class="line"><span style="color:#A6ACCD;">                101.1000.... | mask: 101</span></span>
<span class="line"><span style="color:#A6ACCD;">11.10000.... -&gt; 110.1000.... | mask: 110</span></span>
<span class="line"><span style="color:#A6ACCD;">                111.1000.... | mask: 111</span></span>
<span class="line"><span style="color:#A6ACCD;">----------------------------------------------------------</span></span>
<span class="line"><span style="color:#A6ACCD;">...and so on...</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>And now the most important thing is why all this is needed - <strong>an account gets into the shard if its address starts with a mask from the id</strong>.</p></blockquote><h2 id="accounts" tabindex="-1">Accounts <a class="header-anchor" href="#accounts" aria-hidden="true">#</a></h2><p>An account is identified by its full address, and is completely described by its state.</p><p>Full address consists of a workchain id and an account id. Its string representation could be described with a simple regex - <code>/^(?:-1|0):[0-9a-fA-F]{64}$/</code>. Account id must be equal to the hash of the initial account state, otherwise, it will be impossible to initialize it with this state or do anything with the accumulated funds in the account balance.</p><p>Each account can be in one of possible states:</p><ul><li><code>nonexist</code> - there were no transactions on this account, so it doesn&#39;t have any data. We can say that initially all 2<sup>256</sup> accounts are in this state.</li><li><code>uninit</code> - account has some data, which contains balance and meta info. At this state account doesn&#39;t have any smart contract code/persistent data yet. An account enters this state, for example, when it was <code>nonexist</code> and some other account sent some tokens to it.</li><li><code>active</code> - account has smart contract code, persistent data and balance. At this state it can perform some logic during the transaction and change its persistent data. An account enters this state when it was <code>uninit</code> and there was an incoming message with <code>state_init</code> param (note, that to be able to <em>deploy</em> this account, the <code>state_init</code> hash must be equal to account id).</li><li><code>frozen</code> - account can&#39;t perform any operation, this state contains only previous state hash. When storage fee on account is higher than its balance it enters this state. To <em>unfreeze</em> it you can send an internal message with attached <code>state_init</code> which has the specified hash. It might be hard to reconstruct this (you must apply all transactions) therefore you should never allow such a situation.</li></ul><p><a href="https://github.com/broxus/ton-labs-block/blob/4824b39df2f9665cf78378c9481c4ddcffabe7ae/src/messages.rs#L1707-L1721" target="_blank" rel="noopener noreferrer">Account initial state</a> (* TVC*) contains code and data. In the solidity ABI, data in TVC is a dictionary with 64-bit keys and arbitrary values. All static variables are written to it at the appropriate indexes (see <code>data</code> field in JSON ABI). Thus, to calculate the address of an account, you must use the TVC from the compiler, update its static variables, and compute its hash.</p><h2 id="messages" tabindex="-1">Messages <a class="header-anchor" href="#messages" aria-hidden="true">#</a></h2><p><em>Please refer to <a href="https://docs.ton.dev/86757ecb2/p/45e664-basics-of-free-ton-blockchain/t/20b3af" target="_blank" rel="noopener noreferrer">the docs</a></em></p><blockquote><h3 id="logical-time" tabindex="-1">Logical time <a class="header-anchor" href="#logical-time" aria-hidden="true">#</a></h3><p>Before considering messages, it is necessary to know what is the <em>logical time</em>. It is a non-negative 64-bit integer, assigned to certain events as follows:</p><blockquote><p>If an event <em>e</em> logically depends on events <em>e<sub>1</sub> ,... , e<sub>n</sub></em>, then logical time of <em>e</em> is the smallest non-negative integer that is greater than all logical times of <em>e<sub>i</sub></em></p></blockquote></blockquote><p>In Everscale, messages exist &quot;separately&quot; from transactions as an entity. There are three types of messages:</p><ul><li><p><em>External inbound</em> - doesn&#39;t contain source address but has the destination address, doesn&#39;t have any value. It is used to call contracts from outside or to deploy them.</p><ul><li>There are some limitations on their size, and it is also not guaranteed that they will be delivered in order or that they will be delivered at all.</li></ul></li><li><p><em>Internal</em> - has both source and destination addresses and can have some value. It allows contracts to communicate with each other. There are no reasonable limitations on their size.</p><ul><li>It is important to note that each internal message is unique (because it contains its full source address along with its logical creation time, and all outbound messages created by the same smart contract have strictly increasing logical creation times), so, by the hash of the internal message, you can definitely find it (but the same message can be presented in two transactions, as internal outgoing and internal incoming).</li><li>Order of internal messages is guaranteed (within a single shard). The order of messages is preserved by their logical time.</li><li>Delivery of these messages is also guaranteed.</li><li>Internal messages within one shard can reach the destination in almost the same block, however when message is sent to the account which is in the different shard it may take a long time.</li></ul></li><li><p><em>External outbound</em> - has the source address but doesn&#39;t contain source address, doesn&#39;t have any value. It is used as the events the contracts produce for the outside world. Use them to implement some off-chain logic.</p></li></ul><p>Each message can contain body which is an arbitrary cell. It is used for function input/output or event data.</p><h2 id="transactions" tabindex="-1">Transactions <a class="header-anchor" href="#transactions" aria-hidden="true">#</a></h2><p><em>Please refer to Chapter 4.2 of <a href="https://ton.org/tblkch.pdf" target="_blank" rel="noopener noreferrer">the whitepaper</a></em></p><p>Transaction describes the change of exactly one account.</p><h3 id="phases-of-an-ordinary-transaction" tabindex="-1">Phases of an ordinary transaction <a class="header-anchor" href="#phases-of-an-ordinary-transaction" aria-hidden="true">#</a></h3><p>An ordinary transaction is performed in several <em>phases</em>:</p><ul><li><p><em>Storage phase</em> - collects due storage payments for the account state (including smart-contract code and data, if present) up to the present time. The smart contract may be <em>frozen</em> as as result.</p><ul><li>If the smart contract did not exist before, the storage phase is skipped</li></ul></li><li><p><em>Credit phase</em> - The account is credited with the value of the inbound message received.</p><ul><li>Skipped if the transaction was initiated by an external inbound message</li><li>Executed very first if the <code>bounce</code> flag was set to <code>false</code> in the incoming message</li></ul></li><li><p><em>Computing phase</em> - The code of the smart contract is invoked inside an instance of TVM with adequate parameters, including a copy of the inbound message and of the persistent data, and terminates with an exit code, the new persistent data, and an action list (which includes, for instance, outbound messages to be sent). The processing phase may lead to the creation of a new account (uninitialized or active), or to the activation of a previously uninitialized or frozen account. The gas payment, equal to the product of the gas price and the gas consumed, is exacted from the account balance.</p><ul><li>Validators do not include a transaction into the network if it was generated by an external message and the exit code in this phase is different from a successful one</li></ul></li><li><p><em>Action phase</em> - If the smart contract has terminated successfully (with exit code 0 or 1), the actions from the list are performed. If it is impossible to perform all of them then the transactions is aborted and the account state is rolled back. The transaction is also aborted if the smart contract did not terminate successfully, or if it was not possible to invoke the smart contract at all because it is uninitialized or frozen.</p><ul><li>Note the transaction may be included into the network even if it was generated by an external message (when the previous phase was successful). An included transaction means that fees will be deducted from the account balance even if rolled back.</li></ul></li><li><p><em>Bounce phase</em> - If the transaction has been aborted, and the inbound message has its <code>bounce</code> flag set, then it is &quot;bounced&quot; by automatically generating an outbound message (with the <code>bounce</code> flag clear, but <code>bounced</code> set) to its original sender.</p><ul><li>Almost all value of the origin inbound message is transferred to the generated message.</li></ul></li></ul><h3 id="transaction-fees" tabindex="-1">Transaction fees <a class="header-anchor" href="#transaction-fees" aria-hidden="true">#</a></h3><p><em>Please refer to <a href="https://docs.ton.dev/86757ecb2/p/632251-fee-calculation-details" target="_blank" rel="noopener noreferrer">the docs</a></em></p><p>Transaction fees consist of fees from all executed phases:</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">transaction_fee = storage_fee + gas_fees + total_action_fees </span></span>
<span class="line"><span style="color:#A6ACCD;">  + inbound_external_message_fee + outbound_internal_messages_fee</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ul><li><p><code>storage_fee</code> - contract storage fee since the previous transaction.</p><div class="language-"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">storage_fee = ceil (</span></span>
<span class="line"><span style="color:#A6ACCD;">    (account.bits * bit_price + account.cells * cell_price) * period / 2 ^ 16</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>where <code>bit_price</code> and <code>cell_price</code> and from the network config (p18, e.g. <code>1</code> and <code>500</code> for mainnet)</p></li><li><p><code>gas_fees</code> - fees from the computing phase.</p></li><li><p><code>total_action_fees</code> - fees from action phase.</p></li><li><p><code>inbound_external_message_fee</code> - external message forwarding fee in case the transaction was produced by external message.</p></li><li><p><code>outbound_internal_messages_fee</code> - forwarding fee for outgoing messages.</p></li></ul><p>Based on the above, the cost of executing a transaction can only be calculated by running it locally on the executor. Note, that this will be an approximate value as it depends on time and will be a bit greater at the time the transaction is executed.</p>`,45),i=[o];function r(l,c,h,d,p,u){return a(),t("div",null,i)}var b=e(n,[["render",r]]);export{f as __pageData,b as default};
